# A tool to ensure that the pull requests is correctly formatted for changelog and semantic release
name: tool-pr-checker

on:
  workflow_call:
    inputs:
      python-version:
        description: 'Python version'
        type: string
        required: false
        default: '3.11'
    outputs:
      uses_pip_packaging:
        description: 'Uses pip packaging'
        value: ${{ jobs.packagingCheck.outputs.uses_pip_packaging }}
      uses_conda_packaging:
        description: 'Uses conda packaging'
        value: ${{ jobs.packagingCheck.outputs.uses_conda_packaging }}
      has_pip_api_key_secret:
        description: "Has SOURCE_KEY secret set"
        value: ${{ jobs.packagingCheck.outputs.has_source_key_secret }}
      has_conda_api_key_secret:
        description: "Is PR title correct"
        value: ${{ jobs.packagingCheck.outputs.check-pr-title }}
      check-release-label:
        description: "Is release label set"
        value: ${{ jobs.packagingCheck.outputs.check-release-label }}
      pip_pkg_name:
        description: "Pip package name"
        value: ${{ jobs.packagingCheck.outputs.pip_pkg_name }}
      conda_pkg_name:
        description: "Conda package name"
        value: ${{ jobs.packagingCheck.outputs.conda_pkg_name }}
      pip_version:
        description: "Pip package version"
        value: ${{ jobs.packagingCheck.outputs.pip_version }}
      conda_version:
        description: "Conda package version"
        value: ${{ jobs.packagingCheck.outputs.conda_version }}
    secrets:
      PIP_API_KEY:
        required: false
      CONDA_API_KEY:
        required: false

jobs:
  packagingCheck:
    name: Read toml file containing pip and conda config
    runs-on: ubuntu-latest
    outputs:
      pip_version: ${{ steps.collect-version.outputs.pip_version }}
      conda_version: ${{ steps.collect-version.outputs.conda_version }}
      pip_pkg_name: ${{ steps.collect-version.outputs.pip_pkg_name }}
      conda_pkg_name: ${{ steps.collect-version.outputs.conda_pkg_name }}
      uses_conda_packaging: ${{ steps.collect-version.outputs.uses_conda_packaging }}
      uses_pip_packaging: ${{ steps.collect-version.outputs.uses_pip_packaging }}
    steps:
      - name: Checkout git
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: 3.11

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install toml==0.10.2 requests==2.31.0 semver==3.0.1

      - name: Collect pip and conda config
        id: collect-version
        shell: python
        run: |
          import toml
          import semver
          import requests
          import os

          semantic_data = toml.load("semantic-release.toml")
          pyproject_data = toml.load("pyproject.toml")

          def set_output(name, value):
            with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
                print(f'{name}={value}', file=fh)
          
          def make_semver_compatible(version: str) -> str:
            release_tag = os.environ.get("RELEASE_TAG", "alpha")
            if release_tag in version and "-" not in version:
                version = version.replace(release_tag, f"-{release_tag}")
        
            elif "a" in version and "-" not in version:
                version = version.replace("a", "-alpha.")
        
            return version
          
          def get_latest_version_from_list_of_versions_by_numeric_sorting(versions: list[str]) -> str:
            latest_version = make_semver_compatible(versions[0])
            for ver in versions[1:]:
                semver_compatible = make_semver_compatible(ver)
                if semver.compare(semver_compatible, latest_version) == 1:
                    latest_version = semver_compatible
        
            return latest_version
          
          print(semantic_data)
          print(pyproject_data)
          
          pip_tool = semantic_data["tool"]["pip"]
          conda_tool = semantic_data["tool"]["conda"]
          
          # Make a GET request to pypi and conda URL's to get the latest version
          if pip_tool["enabled"]:
            package_name = pip_tool.get("name_override", pyproject_data["project"]["name"])
            pypi_url = f"https://pypi.org/pypi/{package_name}/json"
            response = requests.get(pypi_url)
            data = response.json()
            latest_version = get_latest_version_from_list_of_versions_by_numeric_sorting(list(data["releases"].keys()))
            
            set_output("uses_pip_packaging", 'true')
            set_output("pip_pkg_name", package_name)
            set_output("pip_version", latest_version)
          else:
            set_output("uses_pip_packaging", 'false')
          
          if conda_tool["enabled"]:
            package_name = conda_tool.get("name_override", pyproject_data["project"]["name"])
            owner = conda_tool['owner']
            conda_url = f"https://api.anaconda.org/package/{owner}/{package_name}"
            response = requests.get(conda_url)
            data = response.json()
            versions = [file["version"] for file in data["files"]]
            latest_conda_version = get_latest_version_from_list_of_versions_by_numeric_sorting(versions)
            
            set_output("conda_pkg_name", package_name)
            set_output("conda_version", latest_conda_version)
            set_output("uses_conda_packaging", 'true')
          else:
            set_output("uses_conda_packaging", 'false')
          
          # Todo: should compare current pyproject.toml version with latest version(s) from pypi and anaconda