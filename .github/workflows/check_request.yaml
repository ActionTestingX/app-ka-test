name: Review Pull Request

on:
  pull_request_target:
    types: [ opened, synchronize, edited, labeled ]
    branches:
      - main

permissions:
  pull-requests: write

# Use concurrency to ensure that only one instance of this workflow is running at a time
concurrency:
  group: pr-lint-checker-${{ github.sha }}
  cancel-in-progress: true

jobs:
  default-label:
    name: Add label to PR
    runs-on: ubuntu-latest
    steps:
      - name: Add Default "release-skip" Label to PR (only if not already added)
        if: >-
          !contains(github.event.pull_request.labels.*.name, 'release-auto') &&
          !contains(github.event.pull_request.labels.*.name, 'release-patch') &&
          !contains(github.event.pull_request.labels.*.name, 'release-minor') &&
          !contains(github.event.pull_request.labels.*.name, 'release-major') &&
          !contains(github.event.pull_request.labels.*.name, 'release-skip')
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['release-skip']
            })

  pr-pylint:
    uses: ./.github/workflows/tool-pylint.yaml
    needs: default-label
    with:
      python-version: 3.11

  pr-lint-checker:
    uses: ./.github/workflows/tool-pr-linter.yaml
    needs: default-label
    with:
      python-version: 3.11
    secrets:
      SOURCE_KEY: ${{ secrets.SOURCE_KEY }}

  pip-conda-checker:
    uses: ./.github/workflows/tool-conda-pip-checker.yaml
    needs: default-label
    with:
      python-version: 3.11
    secrets:
      CONDA_API_KEY: ${{ secrets.CONDA_API_KEY }}
      PIP_API_KEY: ${{ secrets.PIP_API_KEY }}

  pr-lint-review:
    name: Python Check Pull Request
    needs: [ pr-lint-checker, pip-conda-checker, pr-pylint ]
    runs-on: ubuntu-latest
    steps:
      - name: Set up Python
        uses: actions/setup-python@v3
        with:
          python-version: 3.11

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install toml==0.10.2

      - name: Checkout PR
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Review linting results and create body for comment
        id: comment_body  # Set an ID for this step to reference its outputs
        shell: python
        run: |
          import os
          import base64
          
          def set_output(name, value, encode_it=False):
            if encode_it:
              value = base64.b64encode(value.encode('utf-8')).decode('utf-8')
            with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
                print(f'{name}={value}', file=fh)
          
          # PR lint results
          has_source_key_str = '${{ needs.pr-lint-checker.outputs.has_source_key_secret }}'
          check_pr_title_str = '${{ needs.pr-lint-checker.outputs.check-pr-title }}'
          check_release_label_str = '${{ needs.pr-lint-checker.outputs.check-release-label }}'
          
          # Python lint results
          pylint_result_str = '${{ needs.pr-pylint.outputs.pylint_result }}'
          isort_result_str = '${{ needs.pr-pylint.outputs.isort_result }}'
          black_result_str = '${{ needs.pr-pylint.outputs.black_result }}'
          ruff_result_str = '${{ needs.pr-pylint.outputs.ruff_result }}'
          
          # Python packaging results
          uses_conda_packaging_str = '${{ needs.pip-conda-checker.outputs.uses_conda_packaging }}'
          uses_pip_packaging_str = '${{ needs.pip-conda-checker.outputs.uses_pip_packaging }}'
          pip_pkg_name_str = '${{ needs.pip-conda-checker.outputs.pip_pkg_name }}'
          conda_pkg_name_str = '${{ needs.pip-conda-checker.outputs.conda_pkg_name }}'
          pip_version_str = '${{ needs.pip-conda-checker.outputs.pip_version }}'
          conda_version_str = '${{ needs.pip-conda-checker.outputs.conda_version }}'
          
          print(f"{has_source_key_str=} {check_pr_title_str=} {check_release_label_str=}")
          
          # Convert the string values to booleans
          has_source_key = has_source_key_str.lower() != 'false'
          check_pr_title = check_pr_title_str.lower() != 'false'
          check_release_label = check_release_label_str.lower() != 'false'
          uses_conda_packaging = uses_conda_packaging_str.lower() != 'false'
          uses_pip_packaging = uses_pip_packaging_str.lower() != 'false'
          pylint_result = pylint_result_str.lower() != 'false'
          isort_result = isort_result_str.lower() != 'false'
          black_result = black_result_str.lower() != 'false'
          ruff_result = ruff_result_str.lower() != 'false'
          
          # Construct the body string
          if [has_source_key, check_pr_title, check_release_label] == [True, True, True]:
            body = "üëã Hi there! I have checked your PR and found no issues. Thanks for your contribution!"
            set_output('LINT_OK', 'true')
          else:
            body = "üëã Hi there! I have checked your PR and found the following issues:\n\n"
            set_output('LINT_OK', 'false')
          
          # PR linting issues
          body += "\nPR Linting results:"
          if check_pr_title is False:
            body += "\n * You need to start PR title with fix: feat: fix!: feat!: chore:"
          
          if check_release_label is False:
            body += "\n * You need to add a release label to your PR. Valid labels: release-XXX (auto, patch, minor, major or skip)"
          
          if has_source_key is False:
            body += "\n * You need to add SOURCE_KEY as a secret to your repo if you want semantic-release to work"
          
          # Python Linting results
          body += "\n\nPython Linting results:\n\n"

          # Start of the table with headers
          body += "| Tool | Result |\n"
          body += "|------|--------|\n"
          
          # Adding rows for each tool with appropriate checkmark or cross
          body += "| Pylint | " + ("‚úÖ" if pylint_result else "‚ùå") + " |\n"
          body += "| Isort | " + ("‚úÖ" if isort_result else "‚ùå") + " |\n"
          body += "| Black | " + ("‚úÖ" if black_result else "‚ùå") + " |\n"
          body += "| Ruff | " + ("‚úÖ" if ruff_result else "‚ùå") + " |\n"
          
          # Python packaging
          if uses_conda_packaging is True or uses_pip_packaging is True:
            body += "\n\nPython Packaging results:\n\n"
            body = "| Packaging Type | Package Name | Version |\n"
            body += "|----------------|--------------|---------|\n"
            
          if uses_conda_packaging:
              body += f"| Conda | {conda_pkg_name_str} | {conda_version_str} |\n"
          
          if uses_pip_packaging:
              body += f"| Pip | {pip_pkg_name_str} | {pip_version_str} |\n"

          # Set the output
          set_output('body', body, True)
          
          print(os.environ['GITHUB_OUTPUT'])

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const bodyBase64 = '${{ steps.comment_body.outputs.body }}'
            const body = Buffer.from(bodyBase64, 'base64').toString('utf-8')
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            })

      - name: Fail if linting failed
        if: steps.comment_body.outputs.LINT_OK == 'false'
        run: exit 1

      #####################################################################################################################

      - name: Collect docker image team and name
        shell: python
        run: |
          import toml
          import os

          data = toml.load("semantic-release.toml")

          def set_output(name, value):
            with open(os.environ['GITHUB_ENV'], 'a') as fh:
                print(f'{name}={value}', file=fh)

          set_output("DOCKER_ENABLED", data["tool"]["docker"]["enabled"])
          set_output("DOCKER_IMAGE_TEAM", data["tool"]["docker"]["team_name"])
          set_output("DOCKER_IMAGE_NAME", data["tool"]["docker"]["image_name"])

          set_output("JSON_ENABLED", data["tool"]["json"]["enabled"])
          set_output("JSON_PACKAGE", data["tool"]["json"]["package_json_path"])
          set_output("JSON_PACKAGE_LOCK", data["tool"]["json"]["package_lock_json_path"])

      #####################################################################################################################

      - name: Echo DOCKER_IMAGE_TEAM & DOCKER_IMAGE_NAME - info only
        run: |
          echo ${{env.DOCKER_ENABLED}}    
          echo ${{env.DOCKER_IMAGE_TEAM}}
          echo ${{env.DOCKER_IMAGE_NAME}}
          echo ${{env.JSON_ENABLED}}    
          echo ${{env.JSON_PACKAGE}}
          echo ${{env.JSON_PACKAGE_LOCK}}

      #####################################################################################################################

      - name: Check if docker image will manage to build with DOCKER_IMAGE_TEAM & DOCKER_IMAGE_NAME
        if: |
          env.DOCKER_ENABLED == 'true' && (
          contains(github.event.pull_request.labels.*.name, 'release-auto') 
          || contains(github.event.pull_request.labels.*.name, 'release-patch') 
          || contains(github.event.pull_request.labels.*.name, 'release-minor') 
          || contains(github.event.pull_request.labels.*.name, 'release-major'))
        run: |
          docker build -t ${{ secrets.CONTAINER_REGISTRY_ACR_URL }}/${{env.DOCKER_IMAGE_TEAM}}/${{env.DOCKER_IMAGE_NAME}}:latest .

      #####################################################################################################################

      - name: Check if acr login is setup correctly
        if: |
          env.DOCKER_ENABLED == 'true' && (
          contains(github.event.pull_request.labels.*.name, 'release-auto') 
          || contains(github.event.pull_request.labels.*.name, 'release-patch') 
          || contains(github.event.pull_request.labels.*.name, 'release-minor') 
          || contains(github.event.pull_request.labels.*.name, 'release-major'))
        uses: docker/login-action@v3.0.0
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY_ACR_URL }}
          username: ${{ secrets.CONTAINER_REGISTRY_ACR_USERNAME }}
          password: ${{ secrets.CONTAINER_REGISTRY_ACR_PASSWORD }}

      #####################################################################################################################
      - name: Check if we can write version to ${{ env.JSON_PACKAGE }} && ${{ env.JSON_PACKAGE_LOCK }}
        if: env.JSON_ENABLED == 'true'
        shell: python
        run: |
          import json
          import os
          f = open("${{ env.JSON_PACKAGE }}", "r") 
          data = json.load(f)
          data["version"] = "${{env.VERSION_ENV_CACHE}}"

          dump = json.dumps(data, indent = 4)

          with open("${{ env.JSON_PACKAGE }}", "w") as outfile:
              outfile.write(dump)

          f = open("${{ env.JSON_PACKAGE_LOCK }}", "r") 
          data = json.load(f)
          data["version"] = "${{env.VERSION_ENV_CACHE}}"

          dump = json.dumps(data, indent = 4)

          with open("${{ env.JSON_PACKAGE_LOCK }}", "w") as outfile:
              outfile.write(dump)

  gitopsCheck:
    needs: pr-lint-review
    runs-on: ubuntu-latest

    steps:
      #####################################################################################################################

      - name: Checkout Source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          path: source

      #####################################################################################################################

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v3
        with:
          python-version: ${{ matrix.python-version }}

      #####################################################################################################################

      - name: Install python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install toml==0.10.2
          pip install ruamel.yaml==0.17.35
          pip install python-semantic-release==8.1.1

      #####################################################################################################################

      - name: Collect semantic release version number
        working-directory: ./source
        run: |
          echo "VERSION_ENV_CACHE=$(semantic-release --noop version)" >> $GITHUB_ENV

      #####################################################################################################################

      - name: No version found, overriding to 0.0.0
        if: env.VERSION_ENV_CACHE == ''
        run: |
          echo "VERSION_ENV_CACHE=0.0.0" >> $GITHUB_ENV

      #####################################################################################################################

      - name: Collect gitops config
        working-directory: ./source
        shell: python
        run: |
          import toml
          import os

          data = toml.load("semantic-release.toml")

          def set_output(name, value):
            with open(os.environ['GITHUB_ENV'], 'a') as fh:
                print(f'{name}={value}', file=fh)

          set_output("DOCKER_IMAGE_TEAM", data["tool"]["docker"]["team_name"])
          set_output("DOCKER_IMAGE_NAME", data["tool"]["docker"]["image_name"])

          set_output("GITOPS_ENABLED", data["tool"]["gitops"]["enabled"])
          set_output("GITOPS_REPO", data["tool"]["gitops"]["repo"])
          set_output("GITOPS_FILE", data["tool"]["gitops"]["file"])
          set_output("GITOPS_KIND", data["tool"]["gitops"]["kind"])
          set_output("GITOPS_IMAGE_PATH", data["tool"]["gitops"]["image_path"])

      #####################################################################################################################

      - name: Echo DOCKER_IMAGE_TEAM & DOCKER_IMAGE_NAME - info only
        run: |
          echo ${{env.DOCKER_ENABLED}}    
          echo ${{env.DOCKER_IMAGE_TEAM}}
          echo ${{env.DOCKER_IMAGE_NAME}}
          echo ${{env.JSON_ENABLED}}    
          echo ${{env.JSON_PACKAGE}}
          echo ${{env.JSON_PACKAGE_LOCK}}
          echo ${{env.VERSION_ENV_CACHE}}

      #####################################################################################################################

      - name: Checkout gitops
        if: env.GITOPS_ENABLED == 'true' && env.GITOPS_REPO != '' && env.GITOPS_FILE != '' && env.GITOPS_KIND != '' && env.GITOPS_IMAGE_PATH != ''
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          repository: "${{ env.GITOPS_REPO }}"
          ssh-key: ${{ secrets.GITOPS_KEY }}
          path: gitops

      #####################################################################################################################

      - name: Collect gitops config
        if: env.GITOPS_ENABLED == 'true' && env.GITOPS_REPO != '' && env.GITOPS_FILE != '' && env.GITOPS_KIND != '' && env.GITOPS_IMAGE_PATH != ''
        working-directory: ./gitops
        shell: python
        run: |
          import ruamel.yaml

          yaml = ruamel.yaml.YAML()

          with open('${{ env.GITOPS_FILE }}', 'r') as file:
              code = list(yaml.load_all(file))
          
              for a in code:
                  if a["kind"] == "${{ env.GITOPS_KIND }}":
                      a${{ env.GITOPS_IMAGE_PATH }} = "${{ secrets.CONTAINER_REGISTRY_ACR_URL }}/${{env.DOCKER_IMAGE_TEAM}}/${{env.DOCKER_IMAGE_NAME}}:${{env.VERSION_ENV_CACHE}}"  
                      with open('${{ env.GITOPS_FILE }}', 'w') as file:
                          yaml.dump_all(code, file)
